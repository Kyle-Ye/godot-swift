// variant-related functionality
extension Godot 
{
    typealias VariantRepresentable  = _GodotVariantRepresentable
    typealias Variant               = _GodotVariant
}
/// protocol Godot.VariantRepresentable 
///     A type that can be represented by a GDScript variant value.
/// #   (1:godot-variant-protocols)
protocol _GodotVariantRepresentable 
{
    /// static var Godot.VariantRepresentable.variantType:Godot.VariantType { get }
    /// required 
    ///     A type hint used by GDScript.
    /// 
    ///     If a conforming type can be represented by more than one GDScript type, 
    ///     this property should return [`VariantType.void`].
    static 
    var variantType:Godot.VariantType
    {
        get 
    }
    // this needs to be a static function, to handle covariant `Self`. 
    // it’s better to not call these methods directly, the preferred form is the  
    // generic methods on `Godot.Unmanaged.Variant`.
    
    /// static func Godot.VariantRepresentable.takeUnretained(_:)
    /// required 
    ///     Attempts to load an instance of [[`Self`]] from an unmanaged variant 
    ///     value, performing an unbalanced retain if successful.
    /// 
    ///     The loaded instance of [[`Self`]] should be independent of the original 
    ///     variant, in memory-management terms. If the original variant value is 
    ///     deinitialized, the loaded instance of [[`Self`]] should still be valid.
    /// 
    ///     Implementations are not required to deep-copy engine reference types. 
    ///     However, their reference counts should be incremented to reflect the 
    ///     fact that Swift has taken ownership of them.
    /// 
    ///     This requirement is declared as a static method in order to handle 
    ///     covariant [[`Self`]], if applicable.
    /// - value :Godot.Unmanaged.Variant 
    ///     An unmanaged GDScript variant value.
    /// - ->    :Self? 
    ///     An instance of [[`Self`]], if it was possible to load it from `value`, 
    ///     or `nil` otherwise.
    static 
    func takeUnretained(_:Godot.Unmanaged.Variant) -> Self?
    /// func Godot.VariantRepresentable.passRetained()
    /// required 
    ///     Stores `self` as an unmanaged variant value, performing an unbalanced 
    ///     retain.
    /// 
    ///     The returned variant value should be independent of the original 
    ///     Swift instance, in memory-management terms. If `self` is deinitialized
    ///     by the Swift runtime, the returned variant should still be valid.
    /// 
    ///     Implementations are not required to deep-copy `self`. However, its 
    ///     reference count should be incremented to reflect the fact that GDScript 
    ///     has taken ownership of the value.
    /// - ->    :Godot.Unmanaged.Variant 
    ///     An unmanaged GDScript variant value.
    func passRetained() -> Godot.Unmanaged.Variant 
}
/// protocol Godot.Variant
/// :   Godot.VariantRepresentable 
///     A type-erased GDScript variant.
/// 
///     Do not conform additional types to this protocol; conform custom
///     types to [`Godot.VariantRepresentable`] instead.
/// #   (0:godot-variant-protocols)
protocol _GodotVariant:Godot.VariantRepresentable
{
}

extension Godot.AnyDelegate:Godot.Variant 
{
    static 
    var variantType:Godot.VariantType 
    {
        .delegate
    }
    static 
    func takeUnretained(_ value:Godot.Unmanaged.Variant) -> Self?
    {
        value.load(where: Godot.AnyDelegate.variantType) 
        {
            (variant:UnsafePointer<godot_variant>) -> Self? in
            
            guard let core:UnsafeMutableRawPointer = 
                Godot.api.1.0.godot_variant_as_object(variant)
            else 
            {
                return nil
            }
            // `godot_variant_as_object` passes object unretained
            return Godot.type(of: core).init(retaining: core) as? Self
        } ?? nil
    }
    func passRetained() -> Godot.Unmanaged.Variant 
    {
        withExtendedLifetime(self) 
        {
            // `godot_variant_new_object` passes the object retained, unlike 
            // `godot_variant_as_object` for some reason
            .init(value: self.core, Godot.api.1.0.godot_variant_new_object)
        }
    } 
}

// basic variants 

/// extension Bool
/// :   Godot.Variant
/// #   (0:godot-core-types)
/// #   (0:)
extension Bool:Godot.Variant 
{
    static 
    var variantType:Godot.VariantType 
    {
        .bool
    }
    static 
    func takeUnretained(_ value:Godot.Unmanaged.Variant) -> Self?
    {
        value.load(where: Self.variantType, Godot.api.1.0.godot_variant_as_bool)
    }
    func passRetained() -> Godot.Unmanaged.Variant 
    {
        .init(value: self, Godot.api.1.0.godot_variant_new_bool)
    }
}
extension FixedWidthInteger where Self:SignedInteger 
{
    static 
    var variantType:Godot.VariantType 
    {
        .int
    }
    static 
    func takeUnretained(_ value:Godot.Unmanaged.Variant) -> Self?
    {
        value.load(where: Self.variantType, Godot.api.1.0.godot_variant_as_int)
            .map(Self.init(exactly:)) ?? nil
    }
    func passRetained() -> Godot.Unmanaged.Variant 
    {
        .init(value: .init(self), Godot.api.1.0.godot_variant_new_int)
    }
}
extension FixedWidthInteger where Self:UnsignedInteger 
{
    static 
    var variantType:Godot.VariantType 
    {
        .int
    }
    static 
    func takeUnretained(_ value:Godot.Unmanaged.Variant) -> Self?
    {
        value.load(where: Self.variantType, Godot.api.1.0.godot_variant_as_uint)
            .map(Self.init(exactly:)) ?? nil
    }
    func passRetained() -> Godot.Unmanaged.Variant 
    {
        .init(value: .init(self), Godot.api.1.0.godot_variant_new_uint)
    }
}
extension BinaryFloatingPoint 
{
    static 
    var variantType:Godot.VariantType 
    {
        .float
    }
    static 
    func takeUnretained(_ value:Godot.Unmanaged.Variant) -> Self?
    {
        value.load(where: Self.variantType, Godot.api.1.0.godot_variant_as_real)
            .map(Self.init(_:))
    }
    func passRetained() -> Godot.Unmanaged.Variant 
    {
        .init(value: .init(self), Godot.api.1.0.godot_variant_new_real)
    }
}

/// extension Int64
/// :   Godot.Variant
/// #   (1:godot-core-types)
/// #   (1:)
extension Int64:Godot.Variant               {}
/// extension Float64
/// :   Godot.Variant
/// #   (2:godot-core-types)
/// #   (2:)
extension Float64:Godot.Variant             {}

extension Float32:Godot.VariantRepresentable{}
extension Float16:Godot.VariantRepresentable{}

extension Int32:Godot.VariantRepresentable  {}
extension Int16:Godot.VariantRepresentable  {}
extension Int8:Godot.VariantRepresentable   {}
extension Int:Godot.VariantRepresentable    {}

extension UInt64:Godot.VariantRepresentable {}
extension UInt32:Godot.VariantRepresentable {}
extension UInt16:Godot.VariantRepresentable {}
extension UInt8:Godot.VariantRepresentable  {}
extension UInt:Godot.VariantRepresentable   {}

extension Godot.NodePath:Godot.Variant 
{
    static 
    var variantType:Godot.VariantType 
    {
        godot_node_path.variantType
    }
    static 
    func takeUnretained(_ value:Godot.Unmanaged.Variant) -> Self?
    {
        value.load(where: Self.variantType)
        {
            .init(retained: Godot.api.1.0.godot_variant_as_node_path($0))
        } 
    }
    func passRetained() -> Godot.Unmanaged.Variant 
    {
        withExtendedLifetime(self)
        {
            Swift.withUnsafePointer(to: self.core) 
            {
                .init(value: $0, Godot.api.1.0.godot_variant_new_node_path)
            }
        }
    }
}
extension Godot.String:Godot.Variant 
{
    static 
    var variantType:Godot.VariantType 
    {
        godot_string.variantType
    }
    static 
    func takeUnretained(_ value:Godot.Unmanaged.Variant) -> Self?
    {
        value.load(where: Self.variantType)
        {
            .init(retained: Godot.api.1.0.godot_variant_as_string($0))
        } 
    }
    func passRetained() -> Godot.Unmanaged.Variant 
    {
        withExtendedLifetime(self)
        {
            Swift.withUnsafePointer(to: self.core) 
            {
                .init(value: $0, Godot.api.1.0.godot_variant_new_string)
            }
        }
    }
}
extension Godot.List:Godot.Variant 
{
    static 
    var variantType:Godot.VariantType 
    {
        godot_array.variantType
    }
    static 
    func takeUnretained(_ value:Godot.Unmanaged.Variant) -> Self?
    {
        value.load(where: Self.variantType)
        {
            .init(retained: Godot.api.1.0.godot_variant_as_array($0))
        }
    }
    func passRetained() -> Godot.Unmanaged.Variant 
    {
        withExtendedLifetime(self)
        {
            Swift.withUnsafePointer(to: self.core) 
            {
                .init(value: $0, Godot.api.1.0.godot_variant_new_array)
            }
        }
    }
}
extension Godot.Map:Godot.Variant 
{
    static 
    var variantType:Godot.VariantType 
    {
        godot_dictionary.variantType
    }
    static 
    func takeUnretained(_ value:Godot.Unmanaged.Variant) -> Self?
    {
        value.load(where: Self.variantType)
        {
            .init(retained: Godot.api.1.0.godot_variant_as_dictionary($0))
        }
    }
    func passRetained() -> Godot.Unmanaged.Variant 
    {
        withExtendedLifetime(self)
        {
            Swift.withUnsafePointer(to: self.core) 
            {
                .init(value: $0, Godot.api.1.0.godot_variant_new_dictionary)
            }
        }
    }
}


// aggregate types 
extension Godot 
{
    /// struct Godot.Plane3<T> 
    /// :   Swift.Hashable
    /// :   Godot.VariantRepresentable 
    /// :   Godot.Variant where T == Swift.Float32
    /// where T:Swift.SIMDScalar & Swift.BinaryFloatingPoint 
    ///     The [`Godot::Plane`](https://docs.godotengine.org/en/stable/classes/class_plane.html) type.
    /// #   (20:godot-core-types)
    /// #   (20:)
    struct Plane3<T>:Hashable where T:SIMDScalar & BinaryFloatingPoint 
    {
        fileprivate 
        let composite:Vector4<T> 
        
        var origin:T 
        {
            self.composite.w
        } 
        var normal:Vector3<T> 
        {
            self.composite[.xyz]
        }
        
        fileprivate 
        init(composite:Vector4<T>) 
        {
            self.composite = composite
        }
        init(normal:Vector3<T>, origin:T) 
        {
            self.composite = normal || origin
        }
        init<U>(_ other:Plane3<U>) where U:SIMDScalar & BinaryFloatingPoint 
        {
            self.init(composite: .init(other.composite))
        }
    }
    /// enum Godot.Transform2<T>
    /// where T:Swift.SIMDScalar & Swift.BinaryFloatingPoint 
    ///     A namespace for 2-dimensional transforms.
    /// #   (30:godot-core-types)
    /// #   (30:)
    enum Transform2<T> where T:SIMDScalar & BinaryFloatingPoint 
    {
        /// struct Godot.Transform2.Affine
        /// :   Swift.Equatable
        /// :   Godot.VariantRepresentable 
        /// :   Godot.Variant where T == Swift.Float32
        ///     The [`Godot::Transform2D`](https://docs.godotengine.org/en/stable/classes/class_transform2d.html) type.
        /// #   (31:godot-core-types)
        /// #   (31:)
        struct Affine:Equatable  
        {
            let matrix:Vector2<T>.Matrix3
            
            init(matrix:Vector2<T>.Matrix3) 
            {
                self.matrix = matrix
            }
            init<U>(_ other:Transform2<U>.Affine) where U:SIMDScalar & BinaryFloatingPoint 
            {
                self.init(matrix: Vector2<T>.cast(other.matrix))
            }
            
            static 
            func == (lhs:Self, rhs:Self) -> Bool 
            {
                lhs.matrix == rhs.matrix
            }
        }
    }
    /// enum Godot.Transform3<T>
    /// where T:Swift.SIMDScalar & Swift.BinaryFloatingPoint 
    ///     A namespace for 3-dimensional transforms.
    /// #   (32:godot-core-types)
    /// #   (32:)
    enum Transform3<T> where T:SIMDScalar & BinaryFloatingPoint 
    {
        /// struct Godot.Transform3.Linear
        /// :   Swift.Equatable
        /// :   Godot.VariantRepresentable 
        /// :   Godot.Variant where T == Swift.Float32
        ///     The [`Godot::Basis`](https://docs.godotengine.org/en/stable/classes/class_basis.html) type.
        /// #   (34:godot-core-types)
        /// #   (34:)
        struct Linear:Equatable 
        {
            let matrix:Vector3<T>.Matrix 
            
            init(matrix:Vector3<T>.Matrix) 
            {
                self.matrix = matrix
            }
            init<U>(_ other:Transform3<U>.Linear) where U:SIMDScalar & BinaryFloatingPoint 
            {
                self.init(matrix: Vector3<T>.cast(other.matrix))
            }
            
            static 
            func == (lhs:Self, rhs:Self) -> Bool 
            {
                lhs.matrix == rhs.matrix
            }
        }
        /// struct Godot.Transform3.Affine
        /// :   Swift.Equatable
        /// :   Godot.VariantRepresentable 
        /// :   Godot.Variant where T == Swift.Float32
        ///     The [`Godot::Transform`](https://docs.godotengine.org/en/stable/classes/class_transform.html) type.
        /// #   (33:godot-core-types)
        /// #   (33:)
        struct Affine:Equatable  
        {
            let matrix:Vector3<T>.Matrix4
            
            init(matrix:Vector3<T>.Matrix4) 
            {
                self.matrix = matrix
            }
            init<U>(_ other:Transform3<U>.Affine) where U:SIMDScalar & BinaryFloatingPoint 
            {
                self.init(matrix: Vector3<T>.cast(other.matrix))
            }
            
            static 
            func == (lhs:Self, rhs:Self) -> Bool 
            {
                lhs.matrix == rhs.matrix
            }
        }
    }
    /// class Godot.ResourceIdentifier
    /// :   Godot.Variant 
    /// final 
    ///     The [`Godot::RID`](https://docs.godotengine.org/en/stable/classes/class_rid.html) type.
    /// #   (-1:godot-core-types)
    /// #   (-1:)
    struct ResourceIdentifier:Hashable 
    {
        let bitPattern:Int
    }
}

extension Quaternion:Godot.VariantRepresentable 
{
    static 
    var variantType:Godot.VariantType 
    {
        godot_quat.variantType
    }
    static 
    func takeUnretained(_ value:Godot.Unmanaged.Variant) -> Self?
    {
        godot_quat.unpacked(variant: value).map(Self.init(_:))
    }
    func passRetained() -> Godot.Unmanaged.Variant 
    {
        godot_quat.variant(packing: .init(self))
    }
}
extension Godot.Plane3:Godot.VariantRepresentable 
{
    static 
    var variantType:Godot.VariantType 
    {
        godot_plane.variantType
    }
    static 
    func takeUnretained(_ value:Godot.Unmanaged.Variant) -> Self?
    {
        godot_plane.unpacked(variant: value).map(Self.init(_:))
    }
    func passRetained() -> Godot.Unmanaged.Variant 
    {
        godot_plane.variant(packing: .init(self))
    }
}

extension Godot.Transform2.Affine:Godot.VariantRepresentable 
{
    static 
    var variantType:Godot.VariantType 
    {
        godot_transform2d.variantType
    }
    static 
    func takeUnretained(_ value:Godot.Unmanaged.Variant) -> Self?
    {
        godot_transform2d.unpacked(variant: value).map(Self.init(_:))
    }
    func passRetained() -> Godot.Unmanaged.Variant 
    {
        godot_transform2d.variant(packing: .init(self))
    }
}
extension Godot.Transform3.Affine:Godot.VariantRepresentable 
{
    static 
    var variantType:Godot.VariantType 
    {
        godot_transform.variantType
    }
    static 
    func takeUnretained(_ value:Godot.Unmanaged.Variant) -> Self?
    {
        godot_transform.unpacked(variant: value).map(Self.init(_:))
    }
    func passRetained() -> Godot.Unmanaged.Variant 
    {
        godot_transform.variant(packing: .init(self))
    }
} 
extension Godot.Transform3.Linear:Godot.VariantRepresentable 
{
    static 
    var variantType:Godot.VariantType 
    {
        godot_basis.variantType
    }
    static 
    func takeUnretained(_ value:Godot.Unmanaged.Variant) -> Self?
    {
        godot_basis.unpacked(variant: value).map(Self.init(_:))
    }
    func passRetained() -> Godot.Unmanaged.Variant 
    {
        godot_basis.variant(packing: .init(self))
    }
} 
extension Godot.ResourceIdentifier:Godot.Variant
{
    static 
    var variantType:Godot.VariantType 
    {
        godot_rid.variantType
    }
    static 
    func takeUnretained(_ value:Godot.Unmanaged.Variant) -> Self?
    {
        godot_rid.unpacked(variant: value)
    }
    func passRetained() -> Godot.Unmanaged.Variant 
    {
        godot_rid.variant(packing: self)
    }
}
extension Quaternion:Godot.Variant              where T == Float32 {}
extension Godot.Plane3:Godot.Variant            where T == Float32 {}
extension Godot.Transform2.Affine:Godot.Variant where T == Float32 {}
extension Godot.Transform3.Affine:Godot.Variant where T == Float32 {}
extension Godot.Transform3.Linear:Godot.Variant where T == Float32 {}

extension Godot.Unmanaged 
{
    /// struct Godot.Unmanaged.Variant 
    ///     An unmanaged GDScript variant.
    struct Variant 
    {
        private 
        var data:godot_variant 
        
        fileprivate 
        init(unsafeData:godot_variant) 
        {
            self.data = unsafeData
        }
        fileprivate 
        var unsafeData:godot_variant 
        {
            self.data 
        } 
        
        fileprivate 
        func load<T>(where type:Godot.VariantType, _ body:(UnsafePointer<godot_variant>) throws -> T) 
            rethrows -> T? 
        {
            try withUnsafePointer(to: self.data){ Self.type(of: $0) == type ? try body($0) : nil }
        }
        
        fileprivate 
        init<T>(value:T, _ body:(UnsafeMutablePointer<godot_variant>, T) throws -> ()) 
            rethrows
        {
            self.data = .init()
            try body(&self.data, value)
        }
        fileprivate 
        init(with body:(UnsafeMutablePointer<godot_variant>) throws -> ()) 
            rethrows
        {
            self.data = .init()
            try body(&self.data)
        }
        
        private static 
        func type(of pointer:UnsafePointer<godot_variant>) -> Godot.VariantType 
        {
            .init(value: .init(Godot.api.1.0.godot_variant_get_type(pointer).rawValue))
        }
    }
}
extension Godot.Unmanaged.Variant 
{
    @available(*, unavailable, message: "unimplemented")
    mutating 
    func retain() 
    {
    }
    mutating 
    func release() 
    {
        Godot.api.1.0.godot_variant_destroy(&self.data)
    }
}
extension Godot.Unmanaged.Variant 
{
    // no corresponding method taking `Void`, as there is nowhere in the framework 
    // this is required, yet at least.
    /* fileprivate static 
    func pass<T, R>(guaranteeing value:T, _ body:(Self) throws -> R) rethrows -> R
        where T:Godot.VariantRepresentable 
    {
        var unmanaged:Self = .pass(retaining: value)
        defer { unmanaged.release() }
        return try body(unmanaged)
    } */
    static 
    func pass<T>(retaining value:T) -> Self 
        where T:Godot.VariantRepresentable 
    {
        value.passRetained()
    }
    static 
    func pass(retaining _:Void) -> Self
    {
        .init(with: Godot.api.1.0.godot_variant_new_nil)
    }
    
    // FIXME: this should really use an atomic swap
    private mutating 
    func assign(_ other:Self) 
    {
        // deinitialize existing value 
        self.release() 
        self = other
    }
    fileprivate mutating 
    func assign<T>(retaining value:T) 
        where T:Godot.VariantRepresentable 
    {
        self.assign(.pass(retaining: value))
    }
    fileprivate mutating 
    func assign(retaining value:Void) 
    {
        self.assign(.pass(retaining: value))
    }
    
    func take<T>(unretained _:T.Type) -> T? 
        where T:Godot.VariantRepresentable 
    {
        // Optional<T> also has a `takeUnretained(_:)` method, which we do 
        // not want to call here
        T.takeUnretained(self)
    }
    func take(unretained _:Void.Type) -> Void?
    {
        withUnsafePointer(to: self.data, Self.type(of:)) == .void ? () : nil
    }
    
    
    fileprivate static 
    func pass<R>(guaranteeing value:Godot.Variant?, _ body:(UnsafePointer<godot_variant>) throws -> R) rethrows -> R
    {
        try Self.pass(guaranteeing: value)
        {
            try withUnsafePointer(to: $0.data, body)
        }
    }
    static 
    func pass<R>(guaranteeing value:Godot.Variant?, _ body:(Self) throws -> R) rethrows -> R
    {
        var unmanaged:Self = .pass(retaining: value)
        defer { unmanaged.release() }
        return try body(unmanaged)
    }
    static 
    func pass(retaining value:Godot.Variant?) -> Self
    {
        value?.passRetained() ?? .pass(retaining: ())
    }
    
    fileprivate mutating 
    func assign(retaining value:Godot.Variant?) 
    {
        self.assign(.pass(retaining: value))
    }

    func take(unretained _:Godot.Variant?.Type) -> Godot.Variant?
    {
        withUnsafePointer(to: self.data)
        {
            switch Self.type(of: $0)
            {
            case .void:
                return nil
            case .bool:
                return Godot.api.1.0.godot_variant_as_bool($0)
            case .int:
                return Godot.api.1.0.godot_variant_as_int($0)
            case .float:
                return Godot.api.1.0.godot_variant_as_real($0)
            
            case .resourceIdentifier:
                return Godot.api.1.0.godot_variant_as_rid($0).unpacked
            
            case .vector2:
                return Godot.api.1.0.godot_variant_as_vector2($0).unpacked
            case .vector3:
                return Godot.api.1.0.godot_variant_as_vector3($0).unpacked
            case .vector4:
                return Godot.api.1.0.godot_variant_as_color($0).unpacked
            case .quaternion:
                return Godot.api.1.0.godot_variant_as_quat($0).unpacked
            case .plane3:
                return Godot.api.1.0.godot_variant_as_plane($0).unpacked
            
            case .rectangle2:
                return Godot.api.1.0.godot_variant_as_rect2($0).unpacked
            case .rectangle3:
                return Godot.api.1.0.godot_variant_as_aabb($0).unpacked
            
            case .affine2:
                return Godot.api.1.0.godot_variant_as_transform2d($0).unpacked
            case .affine3:
                return Godot.api.1.0.godot_variant_as_transform($0).unpacked
            case .linear3:
                return Godot.api.1.0.godot_variant_as_basis($0).unpacked
            
            case .nodePath:
                return Godot.NodePath.init(retained: 
                    Godot.api.1.0.godot_variant_as_node_path($0))
            case .string:
                return Godot.String.init(retained: 
                    Godot.api.1.0.godot_variant_as_string($0))
            case .list:
                return Godot.List.init(retained: 
                    Godot.api.1.0.godot_variant_as_array($0))
            case .map:
                return Godot.Map.init(retained: 
                    Godot.api.1.0.godot_variant_as_dictionary($0))
            
            case .uint8Array:
                return Godot.Array<UInt8>.init(retained: 
                    Godot.api.1.0.godot_variant_as_pool_byte_array($0))
        	case .int32Array:
                return Godot.Array<Int32>.init(retained: 
                    Godot.api.1.0.godot_variant_as_pool_int_array($0))
        	case .float32Array:
                return Godot.Array<Float32>.init(retained: 
                    Godot.api.1.0.godot_variant_as_pool_real_array($0))
        	case .stringArray:
                return Godot.Array<Swift.String>.init(retained: 
                    Godot.api.1.0.godot_variant_as_pool_string_array($0))
        	case .vector2Array:
                return Godot.Array<Vector2<Float32>>.init(retained: 
                    Godot.api.1.0.godot_variant_as_pool_vector2_array($0))
        	case .vector3Array:
                return Godot.Array<Vector3<Float32>>.init(retained: 
                    Godot.api.1.0.godot_variant_as_pool_vector3_array($0))
        	case .vector4Array:
                return Godot.Array<Vector4<Float32>>.init(retained: 
                    Godot.api.1.0.godot_variant_as_pool_color_array($0))
                    
            case .delegate:
                guard let core:UnsafeMutableRawPointer = 
                    Godot.api.1.0.godot_variant_as_object($0)
                else 
                {
                    Godot.print(error: "encountered nil delegate pointer while unwrapping variant")
                    return nil
                }
                // loading an object pointer from a variant does not seem to 
                // increment its reference count, so we take it unretained
                return Godot.type(of: core).init(retaining: core)
            
            case let type:
                Godot.print(error: "unknown variant type (\(type)), check version compatibility!")
                return nil
            }
        }
    }
}

extension Godot.VariadicArguments:RandomAccessCollection, MutableCollection
{
    var startIndex:Int 
    {
        self.arguments.startIndex
    }
    var endIndex:Int 
    {
        self.arguments.endIndex
    }
    
    func take<T>(unretained _:T.Type, at index:Int) -> T? 
        where T:Godot.VariantRepresentable 
    {
        self[unmanaged: index].take(unretained: T.self) 
    } 
    func take(unretained _:Void.Type, at index:Int) -> Void? 
    {
        self[unmanaged: index].take(unretained: Void.self) 
    } 
    mutating 
    func assign<T>(retaining value:T, at index:Int) 
        where T:Godot.VariantRepresentable 
    {
        self[unmanaged: index].assign(retaining: value) 
    } 
    mutating 
    func assign(retaining value:Void, at index:Int) 
    {
        self[unmanaged: index].assign(retaining: value) 
    } 
    
    subscript(index:Int) -> Godot.Variant? 
    {
        get 
        {
            self[unmanaged: index].take(unretained: Godot.Variant?.self) 
        }
        set(value) 
        {
            self[unmanaged: index].assign(retaining: value)
        }
    } 
    // this type does not own the variants, so it should be safe to subscript them 
    // without retaining them
    private 
    subscript(unmanaged index:Int) -> Godot.Unmanaged.Variant 
    {
        get 
        {
            self.arguments[index].pointee
        }
        set(value)
        {
            self.arguments[index].pointee = value
        }
    } 
}

extension Optional:Godot.VariantRepresentable where Wrapped:Godot.VariantRepresentable 
{
    // apparently, `GODOT_VARIANT_TYPE_NIL` means “unknown type” in this context
    static 
    var variantType:Godot.VariantType
    {
        .void 
    }
    static 
    func takeUnretained(_ value:Godot.Unmanaged.Variant) -> Self?
    {
        if let wrapped:Wrapped  = value.take(unretained: Wrapped.self)
        {
            return .some(wrapped)
        }
        else if let _:Void      = value.take(unretained: Void.self) 
        {
            return .some(.none)
        }
        else 
        {
            return nil 
        }
    }
    func passRetained() -> Godot.Unmanaged.Variant 
    {
        if let wrapped:Wrapped = self 
        {
            return .pass(retaining: wrapped)
        }
        else 
        {
            return .pass(retaining: ())
        }
    }
}
